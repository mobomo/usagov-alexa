<?php

use \Drupal\node\Entity\NodeType;
use \Drupal\field\Entity\FieldConfig;
use \Drupal\field\Entity\FieldStorageConfig;

/**
 * Loads a field configuration if it exists in Drupal. Otherwise creates it from a YAML file.
 * 
 * @param string $fieldName
 *   The machine name of the field.
 * @param string $nodeTypeBundle
 *   The bundle (machine name) of the node type.
 * @param string|null $filePath
 *   The path of the YAML file. If null or no file exists at that location,
 *   it will try to load the file using the field name instead.
 * 
 * @return FieldConfig|null
 *   Returns the FieldConfig for that field name and node type. null if unable to load or create.
 */
function loadOrCreateFieldConfig( string $fieldName, string $nodeTypeBundle, string|null $filePath = null ) : FieldConfig|null {
  $fieldConfig = FieldConfig::loadByName('node', $nodeTypeBundle, $fieldName);

  // If the field doesn't exist in the content type, add it in.
  if ( empty($fieldConfig) ) {
    // Attempt to load the field storage config for the field.
    $fieldStorage = loadOrCreateFieldStorageConfig($fieldName);

    if ( !empty($fieldStorage) ) {
      // With a valid field storage, add the field to the node type.
      $fieldConfigKeys = [
        'id',
        'field_name',
        'entity_type',
        'bundle',
        'label',
        'description',
        'required',
        'translatable',
        'default_value',
        'default_value_callback',
        'settings',
        'field_type'
      ];

      $fileContents = null;
      if ( !empty($filePath) ) {
        $fileContents = file_get_contents($filePath);
      }
      if ( empty($fileContents) ) {
        // Failed to load or no filepath provided
        $fileContents = file_get_contents(getConfigFilePath() . "/field_config/field.field.node.$nodeTypeBundle.$fieldName.yml");
      }

      if ( !empty($fileContents) ) {
        try {
          // Attempt to create the field storage config with loaded data, and return it if successful.
          $fieldConfigData = \Drupal\Component\Serialization\Yaml::decode($fileContents);
          $fieldConfigData['bundle'] = $nodeTypeBundle;
          // TODO
          $fieldConfig = FieldConfig::create(array_intersect_key($fieldConfigData, array_flip($fieldConfigKeys)));
          $saveSuccessful = $fieldConfig->save();

          if ( $saveSuccessful ) {
            return $fieldConfig;
          }
          return null;
        } catch ( Exception $e ) {
          error_log("Failed to create new field config $fieldName:    {$e->getMessage()}");
          return null;
        }
      }

      return null;
    }

    return null;
  }

  return $fieldConfig;
}

/**
 * Loads a field storage configuration if it exists in Drupal. Otherwise creates it from a YAML file.
 * 
 * @param string $fieldName
 *   The machine name of the field.
 * @param string|null $filePath
 *   The path of the YAML file. If null or no file exists at that location,
 *   it will try to load the file using the field name instead.
 * 
 * @return FieldStorageConfig|null
 *   The FieldStorageConfig for that field name. null if unable to load or create.
 */
function loadOrCreateFieldStorageConfig( string $fieldName, string|null $filePath = null ) : FieldStorageConfig|null {
  $fieldStorageConfig = FieldStorageConfig::loadByName('node', $fieldName);

  if ( empty($fieldStorageConfig) ) {
    // TODO
    $fieldStorageKeys = [
      'id',
      'field_name',
      'entity_type',
      'type',
      'settings',
      'module',
      'locked',
      'cardinality',
      'translatable',
      'indexes',
      'persist_with_no_fields',
      'custom_storage'
    ];

    $fileContents = null;
    if ( !empty($filePath) ) {
      $fileContents = file_get_contents($filePath);
    }
    if ( empty($fileContents) ) {
      // Failed to load or no filepath provided
      $fileContents = file_get_contents(getConfigFilePath() . "/field_storage_config/$fieldName.yml");
    }

    if ( !empty($fileContents) ) {
      try {
        // Attempt to create the field storage config with loaded data, and return it if successful.
        $fieldStorageData = \Drupal\Component\Serialization\Yaml::decode($fileContents);
        $fieldStorageConfig = FieldStorageConfig::create(array_intersect_key($fieldStorageData, array_flip($fieldStorageKeys)));
        $saveSuccessful = $fieldStorageConfig->save();

        if ( $saveSuccessful ) {
          return $fieldStorageConfig;
        }
        return null;
      } catch ( Exception $e ) {
        error_log("Failed to create new field storage config $fieldName:    {$e->getMessage()}");
        return null;
      }
    }

    return null;
  }

  return $fieldStorageConfig;
}

/**
 * Loads a content type if it exists in Drupal. Otherwise creates it from a yaml file.
 * 
 * @param string $bundle
 *   The bundle (machine name) of the content type.
 * @param string|null $filePath
 *   The path of the YAML file. If null or no file exists at that location,
 *   it will try to load the file using the bundle instead.
 * 
 * @return NodeType|null
 *   Returns the NodeType for that bundle. null if unable to load or create.
 */
function loadOrCreateNodeType( string $bundle, string|null $filePath = null ) : NodeType|null {
  $contentType = NodeType::load($bundle);

  if ( empty($contentType) ) {
    $nodeTypeKeys = [
      'name',
      'type',
      'description',
      'help',
      'new_revision',
      'preview_mode',
      'display_submitted'
    ];

    $fileContents = null;
    if ( !empty($filePath) ) {
      $fileContents = file_get_contents($filePath);
    }
    if ( empty($fileContents) ) {
      // Failed to load or no filepath provided
      $fileContents = file_get_contents(getConfigFilePath() . "/node_type/$bundle.yml");
    }
    if ( !empty($fileContents) ) {
      try {
        // Attempt to create the content type with loaded data, and return it if successful.
        $contentTypeData = \Drupal\Component\Serialization\Yaml::decode($fileContents);
        $contentType = NodeType::create(array_intersect_key($contentTypeData, array_flip($nodeTypeKeys)));
        $saveSuccessful = $contentType->save();

        if ( $saveSuccessful ) {
          return $contentType;
        }
        return null;
      } catch ( Exception $e ) {
        error_log("Failed to create new content type $bundle:    {$e->getMessage()}");
        return null;
      }
    }

    return null;
  }

  return $contentType;
}

function getConfigFilePath() {
  return \Drupal::service('extension.list.module')->getPath('usagov_wizards') . '/config_files';
}

/**
 * Determines whether necessary content types and fields exist, and creates them
 * if they don't. Additionally assigns fields to content types as needed.
 * 
 * Note this uses the content types with machine names "wizard" and "wizard_step"
 */
function prepareContentTypesAndFields() {
  $fieldsToAdd = \Drupal::service('usagov_wizards.wizard')::FIELD_DATA;
  $nodeTypes = array_keys($fieldsToAdd);
  if (($key = array_search('#shared', $nodeTypes)) !== false) {
    unset($nodeTypes[$key]);
  }
  $entityTypeManager = \Drupal::entityTypeManager();
  // First, make sure content types exist. They are Wizard (wizard)
  // and Wizard Step (wizard_step)
  // Then, add required fields. These fields should already exist in the CMS.
  // If they don't, create them first, then add them.

  // First create node types, because they can be referenced
  // by content reference fields.
  foreach ( $nodeTypes as $nodeType ) {
    // Creates the node (content) type if it doesn't exist.
    loadOrCreateNodeType($nodeType);
  }
  
  // Next, create and add fields to them as needed.
  foreach ( $nodeTypes as $nodeType ) {
    // #shared is an array containing machine names of all fields
    // shared by all content types created here (i.e. wizard and wizard_step)
    foreach ( $fieldsToAdd['#shared'] as $fieldToAddMachineName => $fieldToAddData ) {
      loadOrCreateFieldConfig($fieldToAddMachineName, $nodeType);
    }
    // Additionally, add support for non-shared fields.
    if ( isset($fieldsToAdd[$nodeType]) ) {
      foreach ( $fieldsToAdd[$nodeType] as $fieldToAddMachineName => $fieldToAddData ) {
        loadOrCreateFieldConfig($fieldToAddMachineName, $nodeType);
      }
    }
  }
}

function usagov_wizards_install($is_syncing) {
  prepareContentTypesAndFields();
  $nodeTypes = ['wizard', 'wizard_step'];
  foreach ( $nodeTypes as $nodeType) {
    updateFormDisplay($nodeType);
  }
}

function usagov_wizards_theme($existing, $type, $theme, $path) {
    return [
        'usagov_wizards_wizard' => [
            'variables' => [
                'hello' => t('Hello World!'),
                'wizard_tree' => [],
                'wizard_step_form' => ''
            ],
        ],
        'usagov_wizards_wizard_select' => [
            'variables' => [
                'hello' => t('Hello World!'),
                'wizards' => []
            ],
        ],
    ];
}

/**
 * Updates the form display of a given bundle (node type) using data provided
 * in a configuration YAML file.
 * 
 * @param string $bundle
 *   The bundle of the node type to edit.
 * @param string|null $filePath
 *   The path to the configuration file to load. If null, the path will
 *   be automatically determined using the bundle.
 */
function updateFormDisplay( string $bundle, string|null $filePath = null ) : void {
  $fileContents = null;
  if ( !empty($filePath) ) {
    $fileContents = file_get_contents($filePath);
  }
  if ( empty($fileContents) ) {
    // Failed to load or no filepath provided
    $fileContents = file_get_contents(getConfigFilePath() . "/entity_form_display/core.entity_form_display.node.$bundle.default.yml");
  }
  if ( !empty($fileContents) ) {
    try {
      // $formDisplays = [];
      // $fdQuery = \Drupal::entityQuery('entity_form_display')
      //   ->condition('targetEntityType', 'node')
      //   ->condition('bundle', $bundle);
      // $formDisplayIds = $fdQuery->execute();
      // foreach ( $formDisplayIds as $formDisplayId ) {
      //   $fd = \Drupal\Core\Entity\Entity\EntityFormDisplay::load($formDisplayId);
      // }

      // Load form display data from file
      $formDisplayData = \Drupal\Component\Serialization\Yaml::decode($fileContents);
      // Load node type's current form display settings from Drupal
      $formDisplay = \Drupal\Core\Entity\Entity\EntityFormDisplay::load('node.' . $bundle . '.default');
      if ( !empty($formDisplay) ) {
        $formDisplayData = $formDisplayData['content'];
        if ( empty($formDisplayData) ) {
          $formDisplayData = [];
        }
        foreach ( $formDisplayData as $key => $value) {
          $formDisplay->setComponent($key, $value);
        }

        // foreach ( $formDisplayMergeKeys as $key ) {
        //   if ( !empty($formDisplayData[$key] )) {
        //     $newData = array_merge($formDisplay->getComponent($key) ?? [], $formDisplayData[$key]);
        //     $formDisplay->setComponent($key, $newData);
        //   }
        // }
        $formDisplay->save();
      }
    } catch ( Exception $e ) {
      error_log("Failed to modify form display for type $bundle:    {$e->getMessage()}");
    }
  }
}